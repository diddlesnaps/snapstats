@page "/developers"
@implements IDisposable
@inject IGraphQLClient Client
@inject PersistentComponentState ApplicationState

<PageTitle>Snap Store developers statistics | Snapstats.org</PageTitle>
<HeadContent>
	<meta name="description" content="Statistics about Snap Package developers within the Snap Store for Linux" />

	@* Facebook *@
	<meta property="og:type" content="website" />
	<meta property="og:title" content="Snap Store developers statistics | Snapstats.org" />
	<meta property="og:description" content="Statistics about Snap Package developers within the Snap Store for Linux" />
	<meta property="og:image" content="/favicons/android-icon-512x512.png" />
	<meta property="og:image:secure_url" content="/favicons/android-icon-512x512.png" />
	<meta property="og:image:width" content="512" />
	<meta property="og:image:height" content="512" />
	<meta property="og:image:alt" content="Icon of Snapstats.org" />

	@* Twitter *@
	<meta name="twitter:card" content="summary" />
	<meta name="twitter:creator" content="@("@diddledani")" />
	<meta name="twitter:title" content="Snap Store developers statistics | Snapstats.org" />
	<meta name="twitter:description" content="Statistics about Snap Package developers within the Snap Store for Linux" />
	<meta name="twitter:image" content="/favicons/android-icon-512x512.png" />
</HeadContent>

<h1>Developers</h1>

@if (state?.developerCountsByDate is not null && state.developerCountsByDate.developerCounts.Length > 0)
{
	<p>There are <strong>@state.developerCountsByDate.developerCounts.First().total</strong> developers who have published at least one snap.</p>

	<p>
		Developers with published Snaps have each published an average (<a href="https://en.wikipedia.org/wiki/Arithmetic_mean">mean</a>) of <strong>@(state.developerCountsByDate.developerCounts.First().mean)</strong> Snaps.
		The most common number of Snaps published per developer (<a href="https://en.wikipedia.org/wiki/Mode_(statistics)">mode</a>) is <strong>@(state.developerCountsByDate.developerCounts.First().mode)</strong>.
	</p>
}
else
{
	<p>There are an unknown number of developers who have published at least one snap.</p>
}

<DonateButton/>

@if (state?.verifiedDevelopers is not null && state.verifiedDevelopers.Length > 0)
{
	<h2>Verified Developers</h2>
	<p>Below is a list of the <strong>@state.verifiedDevelopers.Length</strong> known <span class='verified'>Verified</span> developers. Between them they have published <strong>@state.verifiedSnapsCount</strong> Snaps:</p>
	<ul>
		@foreach (var developer in state.verifiedDevelopers)
        {
			<li>@developer</li>
		}
	</ul>
}

@code {
	private const string Query = @"
	query {
		developerCountsByDate{
			_id
			developerCounts{
				date
				total
				mean
				mode
				median
			}
		}
		findSnapsCount(developer_validation:VERIFIED)
		verifiedDevelopers
	}
	";

	private IndexState? state;

	private class IndexState
	{
		public DeveloperCountByDate developerCountsByDate { get; set; } = new DeveloperCountByDate();
		public string[] verifiedDevelopers { get; set; } = Array.Empty<string>();
		public int verifiedSnapsCount { get; set; } = 0;
	}

	private PersistingComponentStateSubscription persistingSubscription;

	protected override async Task OnInitializedAsync()
	{
		persistingSubscription = 
			ApplicationState.RegisterOnPersisting(PersistDevelopers);

		if (ApplicationState.TryTakeFromJson<IndexState>(
					"savedstate", out var restored))
		{
			state = restored!;
		}
		else
		{
			GraphQLRequest request = new GraphQLRequest
			{
				Query = Query,
			};
			var response = await Client.SendQueryAsync<DevelopersQuery>(request).ConfigureAwait(false);
			state = new()
				{
					developerCountsByDate = response.Data?.developerCountsByDate ?? new DeveloperCountByDate(),
					verifiedDevelopers = response.Data?.verifiedDevelopers ?? Array.Empty<string>(),
					verifiedSnapsCount = response.Data?.findSnapsCount ?? 0,
				};
		}
    }

	private Task PersistDevelopers()
    {
        ApplicationState.PersistAsJson("savedstate", state);

        return Task.CompletedTask;
    }

	void IDisposable.Dispose()
    {
        persistingSubscription.Dispose();
    }
}
